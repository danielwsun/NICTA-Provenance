package com.nicta.provenance.pipeline;

import com.nicta.provenance.ProvConfig;

import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

/**
 * @author Trams Wang
 * @version 1.3
 * Date: Jan. 27, 2016
 *
 *   SemanticsInferer is used for extracting the abstract semantics structure of the running pipeline,
 * providing an interface for user to get a visual of it.
 */
public class SemanticsInferer {

    /**
     * @author Trams Wang
     * @version 1.1
     * Date: Jan. 22, 2016
     *
     *   This class is used to store information of pipeline (intermediate)data.
     */
    public class DataNode{
        public ProcessNode producer;
        public String name;
        public ArrayList<ProcessNode> succs;
        double trustworthiness;
        double score;
        public int tag;

        public DataNode()
        {
            producer = null;
            name = null;
            succs = new ArrayList<ProcessNode>();
            trustworthiness = 0;
            score = 0;
            tag = 0;
        }
    }

    /**
     * @author Trams Wang
     * @version 1.1
     * Date: Jan. 22, 2016
     *
     *   This class is used to store information of pipeline processing unit.
     */
    public class ProcessNode{
        public ArrayList<DataNode> preds;
        public String name;
        public DataNode result;
        double trustworthiness;
        double score;
        public int tag;

        public ProcessNode()
        {
            preds = new ArrayList<DataNode>();
            name = null;
            result = null;
            trustworthiness = 0;
            score = 0;
            tag = 0;

        }
    }

    private String name_space;
    private HashMap<String, DataNode> datas;
    private HashMap<String, ProcessNode> procs;

    public SemanticsInferer()
    {
        name_space = ProvConfig.DEF_SEMANTIC_FILE_NAME;
        procs = new HashMap<String, ProcessNode>();
        datas = new HashMap<String, DataNode>();
    }

    /**
     *   Create an instance of SemanticsInferer that will store the information for the certain
     * name space.
     *
     * @param name_space Name for the name space.
     */
    public SemanticsInferer(String name_space)
    {
        this.name_space = name_space;
        procs = new HashMap<String, ProcessNode>();
        datas = new HashMap<String, DataNode>();
    }

    /**
     *   Learn the knowledge of certain components in the semantics DAG. Link all known components together to make
     * a semantics DAG.
     *
     * @param srcvars Pig Latin script variable names that are used in the following processing
     *                unit denoted by "processor". Since there may be more than one source variables,
     *                all variable names shall be seperated by ','.
     *                E.g. "v1,v2,v3"
     * @param processor Name for the processing unit which takes the source variables and generate
     *                  destination variable.
     * @param dstvar Pig Latin script variable name that stores the result generated by above processing
     *               unit.
     */
    public void absorb(String srcvars, String processor, String dstvar) throws IOException
    {
        if (null == processor) throw new IOException("Inferring from null processor.");
        if (null == srcvars && null == dstvar) throw new IOException("Inferring from null source and destination.");

        ProcessNode proc_node = procs.get(processor);
        if (null == proc_node)
        {
            proc_node = new ProcessNode();
            proc_node.name = processor;
            procs.put(processor, proc_node);
        }

        if (null != srcvars)
        {
            String[] srcvar_list = srcvars.split(",");
            int cnt = srcvar_list.length;
            DataNode[] src_nodes = new DataNode[cnt];
            for (int i = 0; i < cnt; i++)
            {
                src_nodes[i] = datas.get(srcvar_list[i]);
                if (null == src_nodes[i])
                {
                    src_nodes[i] = new DataNode();
                    src_nodes[i].name = srcvar_list[i];
                    datas.put(srcvar_list[i], src_nodes[i]);
                }
            }

            /* Link src with proc*/
            for (DataNode dn : src_nodes)
            {
                if (!dn.succs.contains(proc_node))
                {
                    dn.succs.add(proc_node);
                }
                if (!proc_node.preds.contains(dn))
                {
                    proc_node.preds.add(dn);
                }
            }
        }

        if (null != dstvar)
        {
            DataNode dst_node = datas.get(dstvar);
            if (null == dst_node)
            {
                dst_node = new DataNode();
                dst_node.name = dstvar;
                datas.put(dstvar, dst_node);
            }

            /* Link proc with dst*/
            if (null == proc_node.result || null == dst_node.producer)
            {
                proc_node.result = dst_node;
                dst_node.producer = proc_node;
            }
        }
    }

    /**
     *   Display the semantic structure learned from the pipeline.
     *
     * @param out Stream for output.
     * @throws IOException
     */
    public void displayStructure(OutputStream out) throws IOException
    {
        out.write("--Processors: \n".getBytes());
        for (Map.Entry<String, ProcessNode> entry : procs.entrySet())
        {
            ProcessNode pn = entry.getValue();
            out.write(('<' + pn.name + ">(" + Double.toString(pn.score) + "): "
                    + ((null == pn.result)?"":pn.result.name) + '\n').getBytes());
        }
        out.write("--Data: \n".getBytes());
        for (Map.Entry<String, DataNode> entry : datas.entrySet())
        {
            DataNode dn = entry.getValue();
            out.write(('[' + dn.name + "]: ").getBytes());
            for (ProcessNode pn : dn.succs)
            {
                out.write((pn.name + ',').getBytes());
            }
            out.write('\n');
        }
        out.write("---------------\n".getBytes());
    }

    public DataNode dataNode(String name)
    {
        return datas.get(name);
    }

    public ProcessNode processNode(String name)
    {
        return procs.get(name);
    }
}
